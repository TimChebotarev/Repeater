{"version":3,"sources":["utils.js","App.js","serviceWorker.js","index.js"],"names":["recordAudio","Promise","resolve","a","navigator","mediaDevices","getUserMedia","audio","stream","mediaRecorder","MediaRecorder","audioChunks","addEventListener","event","push","data","stop","console","log","audioBlob","Blob","audioUrl","URL","createObjectURL","Audio","play","state","length","start","recognition","window","SpeechRecognition","webkitSpeechRecognition","finalTranscript","isStarted","onUpdateCallback","speechRecognition","lang","interimResults","maxAlternatives","continuous","onresult","interimTranscript","i","resultIndex","len","results","transcript","isFinal","onend","setCallback","callback","App","useState","setTranscript","r","setR","recogn","handlerStart","useCallback","then","handlerStop","onRecognUpdate","final","includes","onended","className","onClick","readOnly","value","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.aece248c.chunk.js","sourcesContent":["/* eslint-disable no-unused-expressions */\n\nconst beep = () => {\n  var snd = new Audio(\"data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=\");\n  snd.play();\n}\n\nconst recordAudio = () =>\n  new Promise(async resolve => {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    const mediaRecorder = new MediaRecorder(stream);\n    const audioChunks = [];\n\n    mediaRecorder.addEventListener(\"dataavailable\", event => {\n      audioChunks.push(event.data);\n    });\n\n    const start = () => {\n      console.log('record started')\n      mediaRecorder.start();\n    }\n\n    const stop = () =>\n      new Promise(resolve => {\n        mediaRecorder.addEventListener(\"stop\", () => {\n          console.log('record stoped')\n          const audioBlob = new Blob(audioChunks);\n          const audioUrl = URL.createObjectURL(audioBlob);\n          const audio = new Audio(audioUrl);\n          const play = () => audio.play();\n          resolve({ audioBlob, audioUrl, audio, play });\n        });\n\n        if (mediaRecorder.state !== 'inactive')\n          mediaRecorder.stop();\n        audioChunks.length = 0\n      });\n\n    resolve({ start, stop });\n  });\n\n// const sleep = time => new Promise(resolve => setTimeout(resolve, time));\n// (async () => {\n//   const recorder = await recordAudio();\n//   recorder.start();\n//   await sleep(3000);\n//   const audio = await recorder.stop();\n//   audio.play();\n// })();\n\nconst recognition = () => {\n  window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;\n  let finalTranscript = '', isStarted = false, onUpdateCallback = () => { };\n  let speechRecognition = new window.SpeechRecognition();\n  speechRecognition.lang = 'ru-RU';\n  speechRecognition.interimResults = false;\n  speechRecognition.maxAlternatives = 1;\n  speechRecognition.continuous = true;\n  speechRecognition.onresult = (event) => {\n    let interimTranscript = '';\n    for (let i = event.resultIndex, len = event.results.length; i < len; i++) {\n      let transcript = event.results[i][0].transcript;\n      if (event.results[i].isFinal) {\n        finalTranscript += transcript;\n      } else {\n        interimTranscript += transcript;\n      }\n    }\n    // document.querySelector('body').innerHTML = finalTranscript + '<i style=\"color:#ddd;\">' + interimTranscript + '</>';\n    onUpdateCallback(finalTranscript, interimTranscript)\n  }\n\n  speechRecognition.onend = function () {\n    console.log('end')\n    if (isStarted) speechRecognition.start();\n  }\n\n  const start = () => {\n    if (isStarted) return\n    console.log('recognition started')\n    finalTranscript = ''\n    isStarted = true;\n    beep()\n    speechRecognition.start();\n  }\n\n  const stop = () => {\n    if (!isStarted) return\n    console.log('recognition stoped')\n    finalTranscript = ''\n    isStarted = false;\n    speechRecognition.stop();\n  }\n\n  const setCallback = (callback) => {\n    onUpdateCallback = callback\n  }\n\n  return { start, stop, setCallback }\n}\n\nexport { recordAudio, recognition }\n","import React, { useState, useCallback } from 'react';\nimport './App.css';\nimport { recordAudio, recognition } from './utils'\n\nfunction App() {\n  const [transcript, setTranscript] = useState('')\n  const [r, setR] = useState()\n  const [recogn, setRecogn] = useState(recognition())\n\n\n\n  const handlerStart = useCallback(async () => {\n    recordAudio().then(i => {\n      setR(i)\n      i.start()\n      recogn.start()\n    })\n  }, [recogn])\n\n  const handlerStop = useCallback(() => {\n\n    recogn.stop()\n    r.stop()\n\n  }, [r, recogn])\n\n  const onRecognUpdate = useCallback(async (final = '', interm = '') => {\n    let audio\n    setTranscript(final)\n    console.log(final)\n    if (final.includes('очень хорошо')) {\n      console.log('match!!!')\n      recogn.stop()\n      audio = await r.stop()\n      audio.audio.onended = (event) => {\n        handlerStart()\n      };\n      audio.play()\n    }\n  }, [handlerStart, r, recogn])\n\n  recogn.setCallback(onRecognUpdate)\n\n  return (\n    <div className=\"App\">\n      <button className=\"button\" onClick={handlerStart}>Start</button>\n      <button className=\"button\" onClick={handlerStop}>Stop</button>\n      <hr />\n      <textarea className=\"text\" readOnly value={transcript}></textarea>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (\n    // process.env.NODE_ENV === 'production' &&\n    'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}